# for emacs, -*- perl -*- comes closest to VTC syntax
# $Id$

test "Test that errno is thread-local"

server s1 {
	rxreq
	txresp
	rxreq
	txresp
} -start

varnish v1 -vcl+backend {
    C{
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdio.h>
#include <unistd.h>
#include <errno.h>
    }C

	# create a race between two requests to see if errno behaves
	# thread-local: The first client triggers an error and then
	# sleeps. the second client should win the race and clear its
	# errno

    sub vcl_deliver {
	if (req.http.client == "one") {
	    C{
		char buf[16];
		int fd;
		
		fd = open("/foobar/dont/tell/me/this/path/really/exists/"
			  "on/your/system/by/purpose", O_RDONLY);
		
		sleep(2);
		
		sprintf(buf, "%d", errno);
		
		VRT_SetHdr(sp, HDR_RESP, "\006errno:", buf, vrt_magic_string_end);
		
		if (fd)
		    close(fd);
	    }C
	} elsif (req.http.client == "two") {
	    C{
		char buf[16];
		int fd;
		
		/* make sure "one" has done its open */
		    sleep(1);
		
		fd = open("/dev/null", O_RDONLY);
		
		sprintf(buf, "%d", errno);
		
		VRT_SetHdr(sp, HDR_RESP, "\006errno:", buf, vrt_magic_string_end);
		
		if (fd)
		    close(fd);
	    }C
    	} else {
	    error 505 "invalid client header";
    	}
    }
} -start

client c1 {
    	txreq -url "/one" -hdr "Client: one"
	rxresp
        expect resp.status == 200
        expect resp.http.X-Varnish == "1001"
	expect resp.http.errno != "0"
} -start

client c2 {
	txreq -url "/two" -hdr "Client: two"
	rxresp
        expect resp.status == 200
        expect resp.http.X-Varnish == "1002"
	expect resp.http.errno == "0"
} -run

client c1 -wait
